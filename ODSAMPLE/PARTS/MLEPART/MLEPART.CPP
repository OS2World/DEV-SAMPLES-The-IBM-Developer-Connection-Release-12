/*
 *      File:           MLEPart.cpp
 *
 *   Copyright: (c) 1994 by IBM Corp., all rights reserved.
 *
 *   Change History (most recent first):
 *
 *      137691  11/28/95   ced   Fix up exception handling and use exception safe tempobjs
 *      144527  11/21/95   ced   Remove add of kODPropPart property to storage unit during 
 *                               externalization.  Use StdTypIO utilities on storage units.
 *      143654  11/13/95   ced   Apple DR4 IDL changes; removed calls to somSelf->IsInitialzed().
 *      138899  11/12/95   ced   parameter change for SetHandleMouseEvents
 *      137664  09/21/95   aml   API change for ODTransform::TransformPoint
 *      127816  06/29/95   jso   Added Preferred Kind Property
 *      126809  06/24/95   st    InitPart/InitPartFromStorage need to call parent
 *      124960  06/16/95   ced   Remove ActivateFrame, ActivatingWindow and
 *                               FocusLost methods since OpenDoc now does a
 *                               better job of managing the PM focus.
 *      125700  06/14/95   ced   Use ODFacet::SetHandleMouseEvents instead of
 *                               handling WM_HITTEST to control dispatching of
 *                               mouse events over the MLE window.
 *      124235  06/12/95   ced   Handle WM_HITTEST from facet window
 *      123327  05/24/95   jso   added setchangedfromprev call in updatefacet
 *      119548  04/25/95   jso   removed private storage utility functions
 *      120017  04/22/95   ced   Move storage utils to common header file
 *
 *   Copyright: (c) 1993-1994 by IBM Corp., all rights reserved.
 *
 */

/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using:
 *      SOM Emitter emitxtm: 2.41
 */

#ifndef _ALTPOINT_
#include "AltPoint.h"
#endif

#ifndef _EXCEPT_
#include "Except.h"
#endif


#ifndef SOM_Module_mlepart_Source
#define SOM_Module_mlepart_Source
#endif
#define MLEPart_Class_Source
#define VARIABLE_MACROS

#include "mlepart.xih"

#define INCL_GPI
#define INCL_WIN

#define INCL_ODAPI
#define INCL_ODARBITRATOR
#define INCL_ODCANVAS
#define INCL_ODDRAGANDDROP
#define INCL_ODDRAFT
#define INCL_ODERRORS
#define INCL_ODEXCEPT
#define INCL_ODFACET
#define INCL_ODFOCUSSET
#define INCL_ODFRAME
#define INCL_ODMENUBAR
#define INCL_ODSHAPE
//#define INCL_ODSEMANTICINTERFACE
#define INCL_ODSESSION
#define INCL_ODSTORAGEUNIT
#define INCL_ODTRANSFORM
#define INCL_ODUNDO
#define INCL_ODWINDOW
#define INCL_ODWINDOWSTATE
#include <os2.h>

#ifndef _FOCUSLIB_
#include "focuslib.h"
#endif

#ifndef _ODUTILS_
#include "ODUtils.h"
#endif

#ifndef _TEMPOBJ_
#include "TempObj.h"
#endif

#ifndef _STDTYPIO_
#include "StdTypIO.h"
#endif

#ifndef _ORDCOLL_
#include "OrdColl.h"
#endif


#define MLETEXTBUFFERSIZE 1024

//const ODType   kMLEPartValueType   = "MLEPart Text";
const ODType   kKindTestMLE        = "+//ISO 9070/ANSI::113722::US::CI LABS::IBM:Kind:MLEPart";
const ODType   kKindDisplayName   = "MLE Part Kind";
const ODType   kPartHandlerDisplayName = "MLE Part";
const ODType   kPartHandlerName  = "MLEPart";

#define FIXED2LONG(f) (((f) + 0x8000) >> 16)


SOM_Scope void  SOMLINK MLEPartFacetAdded(MLEPart *somSelf,  Environment *ev,
                                          ODFacet* facet)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartFacetAdded");

   SOM_TRY

    MLEPart_parent_SimplePart_FacetAdded(somSelf, ev, facet);

    _fFacets->AddLast(facet);

    HWND hwndFacet, hwndMLE;
    if (hwndFacet = facet->GetFacetHWND(ev))
    {
       hwndMLE = WinCreateWindow(hwndFacet, WC_MLE, _fBuffer,
                                 MLS_IGNORETAB | MLS_HSCROLL | MLS_VSCROLL | MLS_BORDER,
                                 0, 0, 0, 0,
                                 hwndFacet, HWND_TOP, 0, 0, 0);

       facet->SetPartInfo(ev, (ODInfoType)hwndMLE);  // Save handle in facet's part info
       somSelf->GeometryChanged(ev, facet, kODFalse, kODFalse); // Size the window.
       facet->SetHandleMouseEvents(ev, kODPartHandlesMouseEvents);  // [138899] make sure we get the mouse events.
    }

   SOM_CATCH_ALL
   SOM_ENDTRY
}

SOM_Scope void  SOMLINK MLEPartFacetRemoved(MLEPart *somSelf,
                                             Environment *ev,
                                            ODFacet* facet)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartFacetRemoved");

   SOM_TRY

    if (_fFacets->Contains(facet))
      _fFacets->Remove(facet);

    HWND hwndMLE = (HWND)facet->GetPartInfo(ev);
    if (hwndMLE)
       WinDestroyWindow(hwndMLE);

    MLEPart_parent_SimplePart_FacetRemoved(somSelf, ev, facet);

   SOM_CATCH_ALL
   SOM_ENDTRY
}

SOM_Scope void  SOMLINK MLEPartGeometryChanged(MLEPart *somSelf,
                                                Environment *ev,
    ODFacet* facet, ODBoolean clipShapeChanged, ODBoolean externalTransformChanged)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartGeometryChanged");

   SOM_TRY

    ODRect rect;
    HWND hwndMLE = (HWND)facet->GetPartInfo(ev);
    if (hwndMLE) {

       MATRIXLF mtx;
       TempODTransform transform = facet->AcquireFrameTransform(ev, kODNULL);

       // We want to display the MLE if our frame transform specifies
       // only translation and scale (no reflection, rotation or shear).

       if (transform->GetType(ev) < kODLinearXform )
       {
          TempODShape frameShape = facet->GetFrame(ev)->AcquireFrameShape(ev, kODNULL);
          frameShape->GetBoundingBox(ev, &rect);
          ODPoint botLeft = rect.BotLeft(), topRight = rect.TopRight();
          transform->TransformPoint(ev, &botLeft);  // [137664]
          transform->TransformPoint(ev, &topRight); // [137664]
          WinShowWindow(hwndMLE, FALSE);
          WinSetWindowPos(hwndMLE, 0,
                          FIXED2LONG(botLeft.x),
                          FIXED2LONG(botLeft.y),
                          FIXED2LONG(topRight.x - botLeft.x) + 1,
                          FIXED2LONG(topRight.y - botLeft.y) + 1,
                          SWP_MOVE | SWP_SIZE);

          TempODShape tempShape = facet->AcquireAggregateClipShape(ev, kODNULL);
          TempODShape clipShape = tempShape->Copy(ev);
          TempODTransform windowFrameTransform = facet->AcquireWindowFrameTransform(ev, kODNULL);
          clipShape->Transform(ev, windowFrameTransform);

          // Clip shape is in window coords of my facet window.  Move to window coords of the
          // MLE window.

          ODTransform* offset = new ODTransform;
          botLeft.x = -botLeft.x;
          botLeft.y = -botLeft.y;
          offset->SetOffset(ev, &botLeft);
          clipShape->Transform(ev, offset);

          WinSetClipRegion(hwndMLE, clipShape->GetRegion(ev));
          WinShowWindow(hwndMLE, TRUE);
       }
       else
       {
          // We can't properly display the MLE in this frame with the given transform.
          // Hide the window and we'll draw the text into the frame in our Draw method

          WinShowWindow(hwndMLE, FALSE);
       }
    }

   SOM_CATCH_ALL
   SOM_ENDTRY
}

SOM_Scope void  SOMLINK MLEPartExternalize(MLEPart *somSelf,
                                            Environment *ev)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartExternalize");

   SOM_TRY

    ODStorageUnit* su = somSelf->GetStorageUnit(ev);

    ODSURemoveProperty(ev, su, kODPropContents);
    ODSUAddPropValue(ev, su, kODPropContents, kKindTestMLE);
    StorageUnitSetValue(su, ev, MLETEXTBUFFERSIZE, _fBuffer);

   SOM_CATCH_ALL
   SOM_ENDTRY
}

SOM_Scope ODBoolean  SOMLINK MLEPartHandleEvent(MLEPart *somSelf,
                                                 Environment *ev,
                                                ODEventData* event,
                                                ODFrame* frame,
                                                ODFacet* facet,
                                                ODEventInfo* eventInfo)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartHandleEvent");

   SOM_TRY

    ODPoint pt(0, 0);
    if (facet && event->hwnd == facet->GetFacetHWND(ev))
    {
       switch (event->msg)
       {
          case WM_CONTROL:
             switch (SHORT2FROMMP(event->mp1))
             {
                case MLN_SETFOCUS:
                   somSelf->Activate(ev, facet);
                   break;
                case MLN_CHANGE:
                   somSelf->UpdateFacets(ev, facet);
                   break;
             }
             return kODTrue;

          default:
             return kODFalse;
       }
    }
    else
    {
       if (event->msg == WM_CHAR)
          return kODFalse;                   // don't pass keystrokes to base class
       else
          return MLEPart_parent_SimplePart_HandleEvent(somSelf, ev,
                                                       event, frame,
                                                       facet, eventInfo);
    }

   SOM_CATCH_ALL
   SOM_ENDTRY

    return kODFalse;

}
SOM_Scope void  SOMLINK MLEPartInitPart(MLEPart *somSelf,  Environment *ev,
    ODStorageUnit* storageUnit, ODPart* partWrapper)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartInitPart");

   SOM_TRY

    MLEPart_parent_SimplePart_InitPart(somSelf, ev, storageUnit, partWrapper);

    somSelf->CommonInitMLEPart(ev);

    strcpy(_fBuffer, "MLE Part");

    ODSUAddPropValue(ev, storageUnit, kODPropContents, kKindTestMLE);

// [127816]
    ODSUAddPropValue(ev, storageUnit, kODPropPreferredKind, kODISOStr);
// end [127816]

   SOM_CATCH_ALL
   SOM_ENDTRY

}

SOM_Scope void  SOMLINK MLEPartInitPartFromStorage(MLEPart *somSelf,
                                                    Environment *ev,
    ODStorageUnit* storageUnit, ODPart* partWrapper)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartInitPartFromStorage");

   SOM_TRY

    MLEPart_parent_SimplePart_InitPartFromStorage(somSelf, ev, storageUnit, partWrapper);

    somSelf->CommonInitMLEPart(ev);

    ODStorageUnit* su = somSelf->GetStorageUnit(ev);
    su->Focus(ev, kODPropContents, kODPosUndefined, kKindTestMLE, 0, kODPosUndefined);
    StorageUnitGetValue(su, ev, MLETEXTBUFFERSIZE, _fBuffer);

   SOM_CATCH_ALL
   SOM_ENDTRY
}

SOM_Scope void  SOMLINK MLEPartCommonInitMLEPart(MLEPart *somSelf,
                                                        Environment *ev)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartCommonInitMLEPart");

   SOM_TRY

    _fFacets = new ODxOrderedCollection;
    _fBuffer = new char[MLETEXTBUFFERSIZE];
    _fSession = somSelf->GetStorageUnit(ev)->GetSession(ev);
    _fSelectionFocus = _fSession->Tokenize(ev, kODSelectionFocus);

    somSelf->CommonInitSimplePart(ev);

   SOM_CATCH_ALL
   SOM_ENDTRY
}

SOM_Scope void  SOMLINK MLEPartDraw(MLEPart *somSelf,  Environment *ev,
                                       ODFacet* facet, ODShape* invalidShape)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartDraw");

   SOM_TRY

    HWND hwndMLE = (HWND)facet->GetPartInfo(ev);
    if (!hwndMLE || hwndMLE && !WinIsWindowVisible(hwndMLE))
    {
       /*
        * The MLE window is not visible (either we don't have one, or it's
        * hidden because we have a non-linear transform) so we'll just clear
        * our background and draw the text into our facet.
        */

       HPS hps;
       CFocus f(ev, facet, invalidShape, &hps);

       // Draw facet

       ODRect bbox;
       TempODShape frameShape = facet->GetFrame(ev)->AcquireFrameShape(ev, facet->GetCanvas(ev));
       frameShape->GetBoundingBox(ev, &bbox);
       RECTL frameRect;
       bbox.AsRECTL(frameRect);

       POINTL ptl = {0, 0};
       GpiSetColor(hps, CLR_BACKGROUND);
       GpiMove(hps, &ptl);
       ptl.x = frameRect.xRight;
       ptl.y = frameRect.yTop;
       GpiBox(hps, DRO_FILL, &ptl, 0, 0);

       // Draw the text.  First select an outline Courier font.  If the font is not
       // available, then we just punt and go on with the default font.

       GpiSetColor(hps, CLR_DEFAULT);
       FATTRS fat;
       POINTL aptlPoints[TXTBOX_COUNT];
       LONG lcid = 101;
       memset(&fat, 0, sizeof(FATTRS));
       fat.usRecordLength = sizeof(FATTRS);
       strcpy(fat.szFacename, "Courier");
       fat.fsFontUse = FATTR_FONTUSE_OUTLINE | FATTR_FONTUSE_TRANSFORMABLE;
       if (FONT_MATCH == GpiCreateLogFont( hps, 0, lcid, &fat))
       {
          FONTMETRICS fm;
          GpiSetCharSet(hps, lcid);
          SIZEF sizfxBox ;
          sizfxBox.cy = MAKEFIXED(10,0);
          sizfxBox.cx = MAKEFIXED(10,0);
          GpiSetCharBox(hps, &sizfxBox);
       }
       else
       {
          // The requested font is not available.  We'll just go on using the default
          // font, but if it's an image font and our facet has a non-linear transform,
          // then things might not look right.
          ;
       }
       char *tmpbuf = strdup(_fBuffer);
       GpiQueryTextBox(hps, 1, "M", 1, &ptl);
       LONG lLeading = ptl.y + 2;
       ptl.x = 2;
       ptl.y = FIXED2LONG(bbox.top) - lLeading;;
       for (char *p = strtok(tmpbuf,"\r"); p; p = strtok(NULL, "\r")) {
          GpiMove(hps, &ptl);
          if (*p == '\n') p++;
          GpiCharString(hps, strlen(p), p);
          ptl.y -= lLeading;
       }
       free(tmpbuf);
    }
    else
    {
       WinUpdateWindow(hwndMLE);
    }

   SOM_CATCH_ALL
   SOM_ENDTRY
}

SOM_Scope void  SOMLINK MLEPartUpdateFacets(MLEPart *somSelf,  Environment *ev, ODFacet* facet)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartUpdateFacets");

  SOM_TRY

   if (_fIgnoreChange)
      return;

   // The text in the MLE has changed.  Update our text buffer.

   HWND hwndMLE = facet->GetPartInfo(ev);
   WinQueryWindowText(hwndMLE, MLETEXTBUFFERSIZE, _fBuffer);

   // Update any other facets displaying this part.

   ODxOrderedCollectionIterator  facets(_fFacets);
   ODFacet* f = (ODFacet*) facets.First();
   while (facets.IsNotComplete() == kODFalse)
   {
      if (f != facet)
      {
         HWND hwnd = (HWND)f->GetPartInfo(ev);
         if (hwnd && WinIsWindowShowing(hwnd))
         {
            _fIgnoreChange = kODTrue;
            WinSetWindowText(hwnd, _fBuffer);
            _fIgnoreChange = kODFalse;
         }
         else
         {
            f->Invalidate(ev, kODNULL, kODNULL);
         }
      }
      f = (ODFacet*) facets.Next();
   }
   // Tell the draft our part has changed  [123327]
   somSelf->GetStorageUnit(ev)->GetDraft(ev)->SetChangedFromPrev(ev);

  SOM_CATCH_ALL
  SOM_ENDTRY
}

SOM_Scope void  SOMLINK MLEPartFocusAcquired(MLEPart *somSelf,
                                                 Environment *ev,
                                                ODTypeToken focus,
                                                ODFrame* ownerFrame)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartFocusAcquired");

   SOM_TRY

    MLEPart_parent_SimplePart_FocusAcquired(somSelf, ev, focus, ownerFrame);

    if (focus == _fSelectionFocus)
    {
       HWND hwndFocus = WinQueryFocus(HWND_DESKTOP);

       TempODFrameFacetIterator facets = ownerFrame->CreateFacetIterator(ev);
       ODFacet* facet = facets->First(ev);

       HWND hwndMLE = (HWND)facet->GetPartInfo(ev);

       if (hwndMLE && WinIsWindowShowing(hwndMLE) && hwndFocus != hwndMLE)
       {
          WinSetFocus(HWND_DESKTOP, hwndMLE);
       }
       /* Let mouse events go directly to MLE window when active */
       facet->SetHandleMouseEvents(ev, 0);     // [138899] - ced
    }

   SOM_CATCH_ALL
   SOM_ENDTRY
}

SOM_Scope void  SOMLINK MLEPartFocusLost(MLEPart *somSelf,
                                             Environment *ev,
                                            ODTypeToken focus,
                                            ODFrame* ownerFrame)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartFocusLost");

   SOM_TRY

    MLEPart_parent_SimplePart_FocusLost(somSelf, ev, focus, ownerFrame);

    if (focus == _fSelectionFocus)
    {
       TempODFrameFacetIterator facets = ownerFrame->CreateFacetIterator(ev);
       ODFacet* facet = facets->First(ev);

       /* make sure part gets mouse events over MLE while not active */
       facet->SetHandleMouseEvents(ev, kODPartHandlesMouseEvents);
    }

   SOM_CATCH_ALL
   SOM_ENDTRY
}

SOM_Scope void  SOMLINK MLEPartsomInit(MLEPart *somSelf)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartsomInit");

    MLEPart_parent_SimplePart_somInit(somSelf);

    _fFacets = kODNULL;
    _fBuffer = kODNULL;
}

SOM_Scope void  SOMLINK MLEPartsomUninit(MLEPart *somSelf)
{
    MLEPartData *somThis = MLEPartGetData(somSelf);
    MLEPartMethodDebug("MLEPart","MLEPartsomUninit");

    MLEPart_parent_SimplePart_somUninit(somSelf);

    delete _fFacets;
    delete[] _fBuffer;
}


SOM_Scope ISOString  SOMLINK M_MLEPartclsGetODPartHandlerName(M_MLEPart *somSelf,
                                                               Environment *ev)
{
    /* M_MLEPartData *somThis = M_MLEPartGetData(somSelf); */
    M_MLEPartMethodDebug("M_MLEPart","M_MLEPartclsGetODPartHandlerName");

    string partHandlerName = kPartHandlerName;
    return (ISOString) partHandlerName;
}

SOM_Scope string  SOMLINK M_MLEPartclsGetODPartHandlerDisplayName(M_MLEPart *somSelf,
                                                                   Environment *ev)
{
    /* M_MLEPartData *somThis = M_MLEPartGetData(somSelf); */
    M_MLEPartMethodDebug("M_MLEPart","M_MLEPartclsGetODPartHandlerDisplayName");

    string partHandlerDisplayName = kPartHandlerDisplayName;
    return partHandlerDisplayName;
}

SOM_Scope _IDL_SEQUENCE_PartKindInfo  SOMLINK M_MLEPartclsGetODPartKinds(M_MLEPart *somSelf,
                                                                          Environment *ev)
{
    /* M_MLEPartData *somThis = M_MLEPartGetData(somSelf); */
    M_MLEPartMethodDebug("M_MLEPart","M_MLEPartclsGetODPartKinds");

    _IDL_SEQUENCE_PartKindInfo MLEPartInfo;

    // Create structure PartKindInfo  and allocate memory for variable
    PartKindInfo * info = (PartKindInfo *)SOMMalloc(sizeof(PartKindInfo));
    info->partKindName = (ISOString) SOMMalloc(strlen(kKindTestMLE) + 1);
    info->partKindDisplayName = (string)SOMMalloc(strlen(kKindDisplayName)+1);
    info->filenameFilters =  (string)SOMMalloc(strlen("")+1);
    info->filenameTypes =  (string)SOMMalloc(strlen("")+1);
    info->categories =  (string)SOMMalloc(strlen(kODCategoryPlainText)+1);
    info->categoryDisplayName =  (string)SOMMalloc(strlen("Text")+1);
    info->objectID =  (string)SOMMalloc(strlen("")+1);
    // Copy the information into the structure
    strcpy(info->partKindName , kKindTestMLE);
    strcpy(info->partKindDisplayName, kKindDisplayName);
    strcpy(info->filenameFilters, "");
    strcpy(info->filenameTypes, "");
    strcpy(info->categories, kODCategoryPlainText);
    strcpy(info->categoryDisplayName, "Text");
    strcpy(info->objectID, "");


    MLEPartInfo._maximum = 1;
    MLEPartInfo._length = 1;
    MLEPartInfo._buffer = info;
    return MLEPartInfo;
}

SOM_Scope string  SOMLINK M_MLEPartclsGetOLE2ClassId(M_MLEPart *somSelf,
                                                      Environment *ev)
{
    /* M_MLEPartData *somThis = M_MLEPartGetData(somSelf); */
    M_MLEPartMethodDebug("M_MLEPart","M_MLEPartclsGetOLE2ClassId");

    string classID = "";
    return classID;
}

SOM_Scope string  SOMLINK M_MLEPartclsGetWindowsIconFileName(M_MLEPart *somSelf,
                                                              Environment *ev)
{
    /* M_MLEPartData *somThis = M_MLEPartGetData(somSelf); */
    M_MLEPartMethodDebug("M_MLEPart","M_MLEPartclsGetWindowsIconFileName");

    string iconFileName = "";
    return iconFileName;
}
