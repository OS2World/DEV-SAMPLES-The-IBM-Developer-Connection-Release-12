
/*
 *  This file was generated by the SOM Compiler.
 *  Generated using:
 *     SOM incremental update: 2.41
 */


//#ifndef SOM_Module_gtkpart_Source
//#define SOM_Module_gtkpart_Source
//#endif

//#define GraphicsPart_Class_Source
#define VARIABLE_MACROS

#ifndef GraphicsPartMethodDebug
   #define GraphicsPartMethodDebug(c,m) SOMMethodDebug(c,m)
#endif

#define INCL_DOSMODULEMGR
#define INCL_DOSRESOURCES
#define INCL_GPIBITMAPS
#define INCL_GPICONTROL
#define INCL_GPIPRIMITIVES
#define INCL_GPIREGIONS
#define INCL_GPITRANSFORMS
#define INCL_WINACCELERATORS
#define INCL_WINFRAMEMGR
#define INCL_WININPUT
#define INCL_WINMENUS
#define INCL_WINMESSAGEMGR
#define INCL_WINPOINTERS
#define INCL_WINSTDDRAG
#define INCL_WINTRACKRECT
#define INCL_WINWINDOWMGR
#define INCL_WINSHELLDATA
#define INCL_DEV
#define INCL_WINSYS
#define INCL_SPL
#define INCL_SPLDOSPRINT

#define INCL_ODAPI
#define INCL_ODARBITRATOR
#define INCL_ODCANVAS
#define INCL_ODDRAGANDDROP
#define INCL_ODDRAFT
#define INCL_ODERRORS
#define INCL_ODFACET
#define INCL_ODFOCUSSET
#define INCL_ODFRAME
// #define INCL_ODPARTHANDLERINFO
#define INCL_ODSESSION
//#define INCL_ODSEMANTICINTERFACE
#define INCL_ODSHAPE
#define INCL_ODSTORAGEUNIT
#define INCL_ODTRANSFORM
#define INCL_ODUI
#define INCL_ODUNDO
#define INCL_ODWINDOW
#define INCL_ODWINDOWSTATE
#define INCL_ODDOCUMENT
#include <os2.h>

#include "gtkpart.xih"

#ifndef SOM_XEmbeddedFramesIterator_xh
   #include <XFrmIter.xh>
#endif

#ifndef _ORDCOLL_
#include "OrdColl.h"
#endif

#include "debug.hpp"

#define UNDONEEDSFIXINMAYBE

#include "gtkbase.h"
#include "gtkpic.h"
//#include "print.h"

#include "common.hpp"

#include <stdio.h>
//#include <string.h>

struct PRNINFO {
   HDC        hdc;
   HPS        hps;
   PHCINFO    phcInfo;
   PRINTDEST  printDest;
   ODRect     bounds;
};
typedef PRNINFO* PPRNINFO;

#define PRINT_QUEUE_LENGTH 100
#define QUEUENAME_LENGTH   10
#define DRIVERNAME_LENGTH  125
#define LEN_WORKSTRING     256
#define LEN_TITLE          256

#define ulmm2fxPt(mm) ((ODCoordinate)(((float)(mm) / 25.4) * 72 * 65536));
#define PtInRect(pt, rect) (pt.x >= rect.left   && \
                            pt.x <  rect.right  && \
                            pt.y >= rect.bottom && \
                            pt.y <  rect.top)

ULONG _System ViewPrintGetQueue( HWND hwnd, PSZ szQueue) { NOTDONE2("ViewPrintGetQueue"); return 0; };
static HDC _Optlink printer_HDC( PSZ szQueue ) { return (HDC)0; NOTDONE2("printer_HDC"); };
ODUShort DetermineNumberOfPagesinDoc(Environment* ev, ODFrame* frame, ODRect page);

//------------------------------------------------------------------------------
// ¥ PRINTING ¥ PRINTING ¥ PRINTING ¥ PRINTING ¥ PRINTING ¥ PRINTING ¥ PRINTING
//------------------------------------------------------------------------------
typedef struct {
  USHORT size, dummy;
  PSZ    szQueue;
} PRNDLGINFO , *PPRNDLGINFO;

#define PRINT_QUEUE_LENGTH 100


SOM_Scope ODBoolean  SOMLINK GraphicsPartHandlePrinting( GraphicsPart *somSelf,
                                                         Environment *ev,
                                                         ODFrame* frame,
                                                         char *pszQueueName)
{
    GraphicsPartData *somThis = GraphicsPartGetData(somSelf);
    GraphicsPartMethodDebug("GraphicsPart","GraphicsPartHandlePrinting");

    ULONG           ul, cReturned, cTotal, cbNeeded, cForms;
    PPRQINFO3       pqi;
    DEVOPENSTRUC    dos;
    PHCINFO         phcInfo, phc;
    LONG            i, rc;
    BOOL            fResult, bOK;
    CHAR            szWork[LEN_WORKSTRING], *pch, achQueueName[QUEUENAME_LENGTH], achDriverName[DRIVERNAME_LENGTH],
                    *pszTitle, achSpoolerParams[40], achQueueProcParams[8];
    ODWindow*       window;
    HWND            hwndFrame = 0;
    HAB             hab = WinQueryAnchorBlock(HWND_DESKTOP);
    HDC             hdcPrinter, hdcPrinterInfo;
    HPS             hpsPrinter, hpsPrinterInfo;
    SIZEL           sizel;
    PRNINFO         prnInfo;
    ODRect          bounds;

//   window = frame->GetWindow(ev);
   window = frame->AcquireWindow(ev);
   if (window)
      hwndFrame = window->GetPlatformWindow(ev);

   ODDocumentName title = somSelf->GetStorageUnit(ev)->GetDraft(ev)->GetDocument(ev)->GetName(ev);
   if (title.text._length)
   {
      pszTitle = (char*)malloc(title.text._length + 1);
      memcpy(pszTitle, title.text._buffer, title.text._length);
      pszTitle[title.text._length] = 0;
   }
   else
      pszTitle = strdup("Untitled");

   /*
    * Get system default queue
    */

   if (pszQueueName)
      strncpy(achQueueName, pszQueueName, sizeof(achQueueName)-1);
   else {
      ul = PrfQueryProfileString (HINI_PROFILE, "PM_SPOOLER", "QUEUE", NULL, szWork, LEN_WORKSTRING);
      if (ul) {
         /* truncate queuename at terminating semicolon */
         pch = strchr (szWork, ';');
         if (pch) {
            *pch = 0;
            strcpy( achQueueName, szWork  );
         }
      }
      if (!achQueueName[0]) {
         WinMessageBox( HWND_DESKTOP,
                        hwndFrame ? hwndFrame : HWND_DESKTOP,
                        "Error: No Default Print Queue",
                        pszTitle,
                        (USHORT)0,
                        MB_OK | MB_MOVEABLE | MB_CUAWARNING | MB_APPLMODAL);

         free(pszTitle);
         return kODFalse;
      }
   }
   /* get queue settings including the driver data info */
   SplQueryQueue("", achQueueName, 3, NULL, 0, &cbNeeded);
   pqi = (PPRQINFO3)malloc(cbNeeded);
   rc = SplQueryQueue("", achQueueName, 3, pqi, cbNeeded, &cbNeeded);

   if (rc != 0) {
      sprintf(szWork, "Error opening printer queue: %s", achQueueName);
      WinMessageBox( HWND_DESKTOP,
                     hwndFrame ? hwndFrame : HWND_DESKTOP,
                     szWork,
                     pszTitle,
                     (USHORT)0,
                     MB_OK | MB_MOVEABLE | MB_CUAWARNING | MB_APPLMODAL);

      free(pszTitle);
      free(pqi);
      return kODFalse;
   }


   /* Open an info device context and presentation space for the printer */

   memset( &dos,   0, sizeof(dos));
   memset( &sizel, 0, sizeof(sizel));

   dos.pszLogAddress = achQueueName;
   strcpy( achDriverName, pqi->pszDriverName);
   achDriverName[strcspn(achDriverName, ".")] = '\0';
   dos.pszDriverName = (PSZ)achDriverName;
   dos.pdriv = pqi->pDriverData;

   /* Create an OD_QUEUED device context and presentation space for the printer */
   hdcPrinterInfo = DevOpenDC(hab, OD_INFO, "*", 3, (PDEVOPENDATA)&dos, 0);
   hpsPrinterInfo = GpiCreatePS(hab, hdcPrinterInfo, (PSIZEL)&sizel,  PU_PELS | GPIA_ASSOC);

   /* Query available forms and use the currently selected form */

   cForms = DevQueryHardcopyCaps( hdcPrinterInfo, 0, 0, 0);
   phcInfo = (PHCINFO)malloc(sizeof(HCINFO) * cForms);
   DevQueryHardcopyCaps( hdcPrinterInfo, 0, cForms, phcInfo);

   /* Find the first currently selected form */

   for (i=0; i< cForms; i++)
      if (phcInfo[i].flAttributes & HCAPS_CURRENT) break;

   phc = &phcInfo[i];

   GpiAssociate(hpsPrinterInfo, 0);
   GpiDestroyPS(hpsPrinterInfo);
   DevCloseDC(hdcPrinterInfo);

   /* determine the bounds of the root facet in OD coords */

   bounds.left = bounds.bottom = 0;
   bounds.right  = ulmm2fxPt(phc->xRightClip - phc->xLeftClip);
   bounds.top    = ulmm2fxPt(phc->yTopClip - phc->yBottomClip);

   /* Build the device context data for DevOpenDC */
   sprintf(achQueueProcParams, "COP=%d", 1);
   sprintf(achSpoolerParams, "FORM=%s", phc->szFormname);

   memset( &dos,   0, sizeof(dos));
   dos.pszLogAddress = achQueueName;
   strcpy( achDriverName, pqi->pszDriverName);
   achDriverName[strcspn(achDriverName, ".")] = '\0';
   dos.pszDriverName = (PSZ)achDriverName;
   dos.pdriv = pqi->pDriverData;
   dos.pszDataType = "PM_Q_STD";
   dos.pszComment = pszTitle;
   dos.pszQueueProcParams = achQueueProcParams;
   dos.pszSpoolerParams = achSpoolerParams;

   hdcPrinter = DevOpenDC(  hab, OD_QUEUED, "*", 9, (PDEVOPENDATA)&dos, 0);
   hpsPrinter = GpiCreatePS( hab, hdcPrinter, &sizel, PU_PELS | GPIA_ASSOC);

   DevEscape(hdcPrinter, DEVESC_STARTDOC, strlen(pszTitle), pszTitle, 0, 0);

   prnInfo.hps = hpsPrinter;
   prnInfo.hdc = hdcPrinter;
   prnInfo.phcInfo = phc;
   prnInfo.bounds = bounds;

   prnInfo.printDest.cb = sizeof(PRINTDEST);
   prnInfo.printDest.lType = OD_QUEUED;
   prnInfo.printDest.pszToken = "*";
   prnInfo.printDest.pdopData = (PDEVOPENDATA)&dos;
   prnInfo.printDest.fl = 0;
   prnInfo.printDest.pszPrinter = pqi->pszPrinters;

   somSelf->PrintPages(ev, frame, &prnInfo);

   DevEscape( hdcPrinter, DEVESC_ENDDOC, 0, 0, 0, 0);
   GpiAssociate(hpsPrinter, 0);
   GpiDestroyPS(hpsPrinter);

   DevCloseDC(hdcPrinter);

   /* free the buffer allocated for SplEnumQueue call */
   free(phcInfo);
   free(pqi);
   free(pszTitle);

   return kODTrue;
}

SOM_Scope ODFacet*  SOMLINK GraphicsPartBeginPrinting( GraphicsPart *somSelf,
                                                       Environment *ev,
                                                       ODFrame* frame,
                                                       PRNINFO* pPI)
{
    GraphicsPartData *somThis = GraphicsPartGetData(somSelf);
    GraphicsPartMethodDebug("GraphicsPart","GraphicsPartBeginPrinting");

    ODTransform* xtransform = frame->CreateTransform(ev);
    ODShape* clipshape = frame->CreateShape(ev);
    clipshape->SetRectangle(ev, &pPI->bounds);

    ODShape* frameShape = frame->AcquireFrameShape( ev, kODNULL )->Copy( ev );
    ODFrame* prFrame = frame->GetStorageUnit(ev)->GetDraft(ev)->
                CreateFrame(ev,
                            kODNonPersistentFrameObject,
                            kODNULL,
                            frameShape,
                            kODNULL,
                            _fPartWrapper,
                            frame->GetViewType(ev),
                            frame->GetPresentation(ev),
                            kODTrue,
                            kODFalse);
    ODReleaseObject(ev, frameShape);

    prFrame->AcquirePart(ev)->AttachSourceFrame(ev, prFrame, frame);

    ODFacet* prFacet = _fSession->GetWindowState(ev)->
      CreateFacet(ev, prFrame, clipshape, xtransform, kODNULL, kODNULL);

    ODPlatformCanvas* platformCanvas = prFacet->CreatePlatformCanvas(ev, pPI->hps);
    ODCanvas* prCanvas = prFacet->CreateCanvas(ev, kODGPI,
                      platformCanvas, kODFalse, kODFalse);

    prCanvas->SetPlatformPrintJob(ev, kODGPI, &pPI->printDest);
    prFacet->ChangeCanvas(ev, prCanvas);

    clipshape->Release(ev); clipshape = kODNULL;
    xtransform->Release(ev); xtransform = kODNULL;

    prFrame->FacetAdded(ev, prFacet);
    return prFacet;
}

SOM_Scope void  SOMLINK GraphicsPartPrintPage(GraphicsPart *somSelf,  Environment *ev,
                                  ODFacet* prFacet, ODUShort pagenum,
                                  PRNINFO* pPI)
{
    GraphicsPartData *somThis = GraphicsPartGetData(somSelf);
    GraphicsPartMethodDebug("GraphicsPart","GraphicsPartPrintPage");

    ODRect bbox;

    ODShape* frameShape = prFacet->GetFrame(ev)->AcquireFrameShape(ev, kODNULL);
    frameShape->GetBoundingBox(ev, &bbox);

    ODULong height = bbox.top;
    ODULong width  = bbox.right;

    ODPoint    scale  = {0,0};
    ODPoint    offset = {0,0};
    ODUShort   locator = pagenum-1;

    /**************************************************************************/
    /* Calculate scaling factor for extenal transform of root facet.  Scale   */
    /* calcualted using the following formula (for the x factor):             */
    /*                                                                        */
    /*                (pel)              xPels         (pel)   25.4 (mm/inch) */
    /* scaling factor ----- = ------------------------ ----- * ---- --------- */
    /*                (pt)    (xRightClip - xLeftClip) (mm)    72.0 (pt/inch) */
    /*                                                                        */
    /**************************************************************************/
    scale.x = (ODCoordinate)((float)pPI->phcInfo->xPels
                             / (float)(pPI->phcInfo->xRightClip -
                                       pPI->phcInfo->xLeftClip)
                             * 25.4 / 72.0 * 65536.0);

    scale.y = (ODCoordinate)((float)pPI->phcInfo->yPels
                             / (float)(pPI->phcInfo->yTopClip -
                                       pPI->phcInfo->yBottomClip)
                             * 25.4 / 72.0 * 65536.0);

    while (locator) {
      offset.y += (pPI->bounds.top);
      locator--;
      if (PtInRect(offset,bbox))
        continue;
      else {
        offset.y = 0;
        offset.x += (pPI->bounds.right + 1);
      }
    }
    offset.y = bbox.top - offset.y - pPI->bounds.top;

    ODTransform* xtransform = prFacet->CreateTransform(ev);

    ODShape* clipshape = prFacet->CreateShape(ev);
    clipshape->SetRectangle(ev, &pPI->bounds);

    xtransform->SetOffset(ev, &offset);
    clipshape->Transform(ev, xtransform);
    clipshape->Intersect(ev, frameShape);
    ODReleaseObject(ev, frameShape);
    ODShape* invalshape = clipshape->Copy(ev);

    xtransform->Invert(ev);
    xtransform->ScaleBy(ev, &scale);
    prFacet->ChangeGeometry(ev, clipshape, xtransform, kODNULL);
    clipshape->Release(ev); clipshape = kODNULL;
    xtransform->Release(ev); xtransform = kODNULL;

    prFacet->Update(ev, invalshape, kODNULL);
}

SOM_Scope long  SOMLINK GraphicsPartPrintPages(GraphicsPart *somSelf,
                                                 Environment *ev,
                                                ODFrame* frame,
                                                PRNINFO* pPI)
{
    GraphicsPartData *somThis = GraphicsPartGetData(somSelf);
    GraphicsPartMethodDebug("GraphicsPart","GraphicsPartPrintPages");

       ODUShort
                firstPage,
                lastPage,
                realNumberOfPagesinDoc,
                pageNumber;
       ODFacet*   prFacet;

       realNumberOfPagesinDoc = DetermineNumberOfPagesinDoc(ev, frame, pPI->bounds );

       //numberOfCopies = 1;

       firstPage = 1;
       lastPage = realNumberOfPagesinDoc;

       if (realNumberOfPagesinDoc < lastPage)
          lastPage = realNumberOfPagesinDoc;

//     TRY
          prFacet = somSelf->BeginPrinting(ev, frame, pPI);
//        THROW_IF_NULL(prFacet);

          pageNumber = firstPage;
          while (pageNumber <= lastPage /*&& PrError() == noErr*/)
          {
             LONG lOut=0;
             LONG rc = 0;
             somSelf->PrintPage(ev, prFacet, pageNumber, pPI);
             DevEscape( pPI->hdc, DEVESC_NEWFRAME, 0, 0, 0, 0 );
             pageNumber++;
          }

          somSelf->EndPrinting(ev, prFacet);
//     CATCH_ALL
          // garbage collection needs to be improved
//     ENDTRY

       return 0; // no error
}

SOM_Scope void  SOMLINK GraphicsPartEndPrinting(GraphicsPart *somSelf,  Environment *ev,
                                    ODFacet* prFacet)
{
    GraphicsPartData *somThis = GraphicsPartGetData(somSelf);
    GraphicsPartMethodDebug("GraphicsPart","GraphicsPartEndPrinting");

    ODCanvas* prCanvas = prFacet->GetCanvas(ev);
    ODFrame*  prFrame =  prFacet->GetFrame(ev);

    prFrame->FacetRemoved(ev, prFacet);
    delete prCanvas;
    delete prFacet;

    prFrame->Remove(ev);
}

ODUShort DetermineNumberOfPagesinDoc(Environment* ev, ODFrame* frame, ODRect page)
{
  ODRect bbox;

  ODShape* frameShape = frame->AcquireFrameShape(ev, kODNULL);
  frameShape->GetBoundingBox(ev, &bbox);
  frameShape->Release(ev); frameShape = kODNULL;

  ODSLong height = bbox.top-bbox.bottom;
  ODSLong width  = bbox.right-bbox.left;

  ODUShort pages = 0;

  ODSLong wt = width;

  while (wt > 0)
  {
    ODSLong ht = height;
    while (ht > 0)
    {
      ht -= (page.top-page.bottom);
      pages++;
    }

    wt -= (page.right-page.left);
  }

  return pages;
}


