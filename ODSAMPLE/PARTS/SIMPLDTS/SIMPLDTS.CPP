
/*
 *  This file was generated by the SOM Compiler.
 *  Generated using:
 *     SOM incremental update: 2.41
 */

/*
 *      File:           SimplDTS.cpp
 *
 *   Contains:  Implementation of Simple Direct-to-SOM Part
 *
 *   Change History (most recent first):
 *
 *     147078   12/14/95   map  Final changes for DTS version of SIMPLPRT
 *     137691   11/28/95   ced  Fix up exception handling and use exception safe tempobjs
 *     143687   11/27/95   aml  Fix printing bug: background not printed on second page
 *     144744   11/22/95   ced  Remove unnessecary frame->SetPartInfo calls
 *     143654   11/13/95   ced  Apple DR4 IDL changes; new param added to ODWindowState::RegisterWindow
 *     143420   11/11/95   st   use cmddefs.xh not odmenuid.h
 *     123247   09/21/95   jso  Added Category User String
 *     128947   07/25/95   st   Open as window when double click received
 *     128305   07/12/95   map  use new OD.h #defines for INCL_ODxxx
 *     128305   07/07/95   st   put in samples for adding menu items to popups
 *     117197   06/22/95   BLG  open from file in some position/properties as was saved
 *     123260   05/26/95   st   More popup support
 *     123149   05/23/95   ced  Activate on WM_BUTTON1CLICK instead of BUTTON1DOWN.
 *                              Invalidate facet in HighlightChanged
 *     123163   05/23/95   st   added popup menu support
 *     122943   05/21/95   map  Multi-threading name changes
 *     121968   05/11/95   jso  Updated CloneInto to check for existing property
 *     121993   05/11/95   ced  use fIsInitialized flag instead of IsInitialized()
 *                              to better support subclassing.  Add fPartWrapper attrib.
 *     119388   04/29/95   st   added menu handling
 *     120025   04/22/95   ced  Fix 'ternalization of activation state.
 *     120017   04/22/95   ced  Added code to keep list of display frames and
 *                              provide CreateDisplayFramesIterator method for
 *                              derived classes.
 *     119471   04/18/95   pfe  added changes for open as window (part window)
 *
 *     117472   04/17/95   ced  Add overridable AllocFramePartInfo method to
 *                              allow derived classes to subclass PartInfoRec.
 *     117544   04/03/95   map  replaced true/false with kODTrue/kODFalse
 *
 *   To Do:
 *
 *   Copyright: (c) 1993-1994 by IBM Corp., all rights reserved.
 *
 */

/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using:
 *      SOM Emitter emitxtm: 2.38
 */

#define INCL_ODDTS // must be before any OpenDoc header file includes

#ifndef _ALTPOINT_
#include "AltPoint.h"
#endif

#ifndef _EXCEPT_
#include "Except.h"
#endif

#ifndef SOM_Module_simplprt_Source
#define SOM_Module_simplprt_Source
#endif
#define SimpleDTSPart_Class_Source
#define VARIABLE_MACROS

#define INCL_GPICONTROL
#define INCL_GPIPRIMITIVES
#define INCL_GPIREGIONS
#define INCL_GPITRANSFORMS
#define INCL_WININPUT
#define INCL_WINSTDDRAG
#define INCL_WINMENUS
#define INCL_DOSMODULEMGR
#define INCL_DOSRESOURCES

#define INCL_ODAPI
#define INCL_ODARBITRATOR
#define INCL_ODCANVAS
#define INCL_ODDRAGANDDROP
#define INCL_ODDRAFT
#define INCL_ODERRORS
#define INCL_ODFACET
#define INCL_ODFOCUSSET
#define INCL_ODFRAME
#define INCL_ODINFO
#define INCL_ODSHAPE
#define INCL_ODSESSION
#define INCL_ODSTORAGEUNIT
#define INCL_ODSTORAGEUNITVIEW
#define INCL_ODTRANSFORM
#define INCL_ODUI
#define INCL_ODUNDO
#define INCL_ODWINDOW
#define INCL_ODWINDOWSTATE
#include <os2.h>

#ifndef _FOCUSLIB_
#include "focuslib.h"
#endif

#ifndef _ODMATH_
#include "ODMath.h"
#endif

#ifndef _TEMPOBJ_
#include "TempObj.h"
#endif

#ifndef _ODUTILS_
#include "ODUtils.h"
#endif

#ifndef _WINUTILS_
   #include "winutils.h"
#endif

#ifndef _ORDCOLL_
#include "OrdColl.h"
#endif

#include <string.h>

#ifndef _STDTYPIO_
#include "stdtypio.h"
#endif

#include "simpldts.hh"

#define YGRID 32
#define XGRID 32

static const ODPropertyName  kPropFrameInfo = "+//ISO 9070/ANSI::113722::US::CI LABS::IBM:SimpleDTSPart:Property:FrameInfo";
static const ODPropertyName  kPropMouseDownOffset = "+//ISO 9070/ANSI::113722::US::CI LABS::IBM:SimpleDTSPart:Property:MouseDownOffset";

// todo: The following entry almost certainly needs to be placed in a public location
static const ODValueType    kOS2POINTL = "+//ISO 9070/ANSI::113722::US::CI LABS::IBM:Type:POINTL";

const ODType   kSimpleDTSPartPresNormal  = "SimpleDTSPart:Presentation:Normal";
const ODType   kSimpleDTSPartPresPalette = "SimpleDTSPart:Presentation:Palette";
const ODType   kSimpleDTSPartKind            = "+//ISO 9070/ANSI::113722::US::CI LABS::IBM:Kind:SimpleDTSPart";
const ODType   kSimpleDTSPartKindDisplayName = "Simple DTS Part Kind";
const ODType   kPartHandlerName         =  "SimpleDTSPart";
const ODType   kSimpleDTSPartCategory         =  "OpenDoc:Category:Sample";

// The following properties are defined for View->Details handling. It is just a TEST.
// You can find the same #defines in cntnrprt.cpp as well.
static const ODPropertyName  kSimpleDTSPartAddProps = "+//ISO 9070/ANSI::113722::US::CI LABS::IBM:SimplePart:Property:AddProps";
const ODType   kSimpleDTSPartAddProp1         =  "+//ISO 9070/ANSI::113722::US::CI LABS::IBM:SimplePart:Test AddProp1";
const ODType   kSimpleDTSPartAddProp2         =  "+//ISO 9070/ANSI::113722::US::CI LABS::IBM:SimplePart:Test AddProp2";
const ODType   kSimpleDTSPartAddProp3         =  "+//ISO 9070/ANSI::113722::US::CI LABS::IBM:SimplePart:Test AddProp3";
const ODType   kSimpleDTSPartAddProp4         =  "+//ISO 9070/ANSI::113722::US::CI LABS::IBM:SimplePart:Test AddProp4";

const ODCommandID cODColor = 2000;
const ODCommandID cODGray = 2001;
const ODCommandID cODRed = 2002;
const ODCommandID cODGreen = 2003;
const ODCommandID cODYellow = 2004;
const ODCommandID cODBlue = 2005;
const ODCommandID cODMagenta = 2006;
const ODCommandID cODCyan = 2007;
const ODCommandID cODWhite = 2008;
const ODCommandID cODOtherColor = 2009;


// SetBGColorRec is used for Undo/Redo.
struct SetBGColorRec
{
  SetBGColorRec(RGBColor oldColor, RGBColor newColor, ODFrame* frame)
          {fOldColor = oldColor; fNewColor = newColor;
            fFrame = frame;}
  RGBColor   fOldColor;
  RGBColor   fNewColor;
  ODFrame*  fFrame;
};


PartInfoRec* SimpleDTSPart::AllocFramePartInfo( )
{
    PartInfoRec* pInfo = new PartInfoRec;
    return pInfo;
}

ODxOrderedCollectionIterator* SimpleDTSPart::CreateDisplayFramesIterator( )
{
    ODxOrderedCollectionIterator* pIter = new ODxOrderedCollectionIterator(fDisplayFrames);
    return pIter;
}
ODSemanticInterface*  SimpleDTSPart::GetSemanticInterface( )
{
    return (ODSemanticInterface *) 0;
}

void  SimpleDTSPart::CommonInitSimpleDTSPart( )
{
   fDisplayFrames = new ODxOrderedCollection;
   fSession = GetStorageUnit()->GetSession();
   fSelectionFocus = fSession->Tokenize( kODSelectionFocus);
   fMenuFocus = fSession->Tokenize( kODMenuFocus);
   fKeyFocus = fSession->Tokenize( kODKeyFocus);
    fFocusSet = fSession->GetArbitrator()->CreateFocusSet();
   fFocusSet->Add( fSelectionFocus);
   fFocusSet->Add( fMenuFocus);
   fFocusSet->Add( fKeyFocus);


     fMenuBar = fSession->GetWindowState()->CopyBaseMenuBar();
      // It is required that parts instantiate their menu bars from
      // the base OpenDoc menu bar. This maintains consistency in the
      // default menu items and their placement.
      // Since the object is a copy, we can add and subtract menus and
      // items without affecting other running parts.
    if ( fMenuBar ){    // crs - b1c16
       fPopup = fSession->GetWindowState()->CopyBasePopup();
       InstallMenus();
    }
}

ODBoolean  SimpleDTSPart::HandleMouseDown(  ODFacet* facet, ODPoint* where, ODEventData* event)
{
    Activate( facet);

    return kODTrue;
}

void  SimpleDTSPart::MoveResize(  ODFacet* facet, Proxy* selection, ODSLong fs)
{

}

ODBoolean  SimpleDTSPart::HandleMouseDownDrag(  ODFacet* facet, Proxy* selection, ODEventData* event)
{
    return kODFalse;
}

ODBoolean  SimpleDTSPart::HandleMouseDownEdgeResize(  ODFacet* facet, Proxy* selection, POINTL* mouse)
{
    return kODFalse;
}

ODBoolean  SimpleDTSPart::HandleMouseDownCornerResize(  ODFacet* facet, Proxy* selection, POINTL* mouse)
{
    return kODFalse;
}

ODBoolean  SimpleDTSPart::HandleKeyDown(  ODFrame* focusFrame, ODEventData* event)
{
    DosBeep(200,30);
    return kODTrue;
}

ODBoolean  SimpleDTSPart::HandleMenuEvent(  ODFrame* focusFrame, ODEventData* event)
{
    ODBoolean handled = kODFalse;
    ODCommandID command = LONGFROMMP(event->mp1);


    switch (command)
    {
         case VIEW_PROPERTIES:
              {
                //not completely done yet.....
                ODFrameFacetIterator* facets = focusFrame->CreateFacetIterator();
                fSession->GetInfo()->ShowPartFrameInfo(facets->First(), kODFalse);
                delete facets;
                handled = kODTrue;
              }
              break;

       case VIEW_OAWINDOW:
              {
              Open( focusFrame);
              handled = kODTrue;
              }
              break;
       default:
          break;
    }

    return handled;

}

ODBoolean  SimpleDTSPart::HandleMouseMove(  ODFacet* facet, ODPoint* where, ODEventData* event)
{
    return kODTrue;
}


void  SimpleDTSPart::ActivateFrame(  ODFrame* frame)
{
    if (frame != kODNULL) {
    ODBoolean succeeded = kODFalse;

    succeeded = fSession->GetArbitrator()->RequestFocusSet( fFocusSet,frame);

    if (succeeded)
    {
       FocusAcquired( fSelectionFocus, frame);
       FocusAcquired( fMenuFocus, frame);
       FocusAcquired( fKeyFocus, frame);
    }
  }

}

void  SimpleDTSPart::DeActivateFrame(  ODFrame* frame)
{
    if (frame != kODNULL) {
       fSession->GetArbitrator()->RelinquishFocusSet( fFocusSet,frame);
       FocusLost( fSelectionFocus, frame);
       FocusLost( fMenuFocus, frame);
       FocusLost( fKeyFocus, frame);
    }
}

void  SimpleDTSPart::ActivatingWindow(  ODFrame* frame)
{
    PartInfoRec* pInfo = (PartInfoRec*) frame->GetPartInfo();
    if (pInfo->fNeedsActivating)
    {
       ActivateFrame( frame);
       pInfo->fNeedsActivating = kODFalse;
    }
}

void  SimpleDTSPart::DeActivatingWindow(  ODFrame* frame)
{
    PartInfoRec* pInfo = (PartInfoRec*) frame->GetPartInfo();
    TempODFrame tempFrame = fSession->GetArbitrator()->AcquireFocusOwner( fSelectionFocus);
    if (frame == tempFrame)
    {
       if (!pInfo->fNeedsActivating)
       {
          pInfo->fNeedsActivating = kODTrue;
       }
    }
    else
    {
       if (pInfo->fNeedsActivating)
       {
          pInfo->fNeedsActivating = kODFalse;
       }
    }
}


void  SimpleDTSPart::UserSetBGColor(  ODFrame* frame, RGBColor whichColor)
{
#ifdef NOT_YET
    if (whichColor != fContentStruct.fColor)
    {
      SetBGColor( frame, whichColor);
    }
#endif
}

void  SimpleDTSPart::SetBGColor(  ODFrame* aFrame, ODUShort whichColor)
{
#ifdef NOT_YET

   RGBColor newColor = fContentStruct.fColor;

   switch (whichColor)
   {
      break;
      case  cODGray:    newColor = 7 % 8;     break;
      case  cODRed:     newColor = 6 % 8;     break;
      case  cODGreen:   newColor = 5 % 8;     break;
      case  cODYellow:  newColor = 4 % 8;     break;
      case  cODBlue:    newColor = 3 % 8;     break;
      case  cODMagenta: newColor = 2 % 8;     break;
      case  cODCyan:    newColor = 1 % 8;     break;
      case  cODWhite:   newColor = 0 % 8;     break;
      default: break;
   }
   UserSetBGColor( aFrame,newColor);
#endif
}

ODWindow*  SimpleDTSPart::CreateWindow(  ODFrame* sourceFrame)
{
    Rect windRect;
    ODPlatformWindow platformWindow = kODNULL;
    ODWindow* window = kODNULL;

    if (sourceFrame && !sourceFrame->IsRoot()) {
       SWP swp;
       swp.x = 100;
       swp.y = 100;
       swp.cx = 400;
       swp.cy = 400;
       platformWindow = fSession->CreatePlatformWindow( ODPlatformWindowDefaultCreateOptions | FCF_HORZSCROLL | FCF_VERTSCROLL);
       WinSetWindowPos(platformWindow, HWND_TOP, swp.x, swp.y, swp.cx, swp.cy, SWP_SIZE | SWP_MOVE);

     } else {
       platformWindow = fSession->CreatePlatformWindow( ODPlatformWindowDefaultCreateOptions);
    } /* endif */
    window =  fSession->GetWindowState()->
          RegisterWindow( platformWindow, kODFrameObject, (sourceFrame==kODNULL),  // is root
                kODTrue,      // Is resizable
                kODFalse,      // Is floating
                kODTrue,      // should save
                kODTrue,      // should dispose
                fPartWrapper, fSession->Tokenize( kODViewAsFrame), fSession->Tokenize( kODPresDefault), sourceFrame);

    return window;
}

RGBColor  SimpleDTSPart::GetDefaultColor( )
{
    return ( fContentStruct.fColor );
}

void  SimpleDTSPart::SetDefaultColor(  RGBColor color)
{
    fContentStruct.fColor = color;
}

void  SimpleDTSPart::InstallMenus( )
{
    ODPlatformMenuItem mi;
    ODPlatformMenuItem mi2;

    memset((PCH)&mi, 0, sizeof(MENUITEM));
    memset((PCH)&mi2,0, sizeof(MENUITEM));



    fPopup->RemoveMenuItem( kODNULL, VIEW_OAICON);
    fPopup->RemoveMenuItem( kODNULL, VIEW_OATREE);
    fPopup->RemoveMenuItem( kODNULL, VIEW_OADETAILS);

}

SimpleDTSPart::SimpleDTSPart( )
{

    fFrameGroupIDCounter = 1;

    fPartWrapper = kODNULL;

    fContents = kODNULL;

    fFocusSet = kODNULL;

    fSemtIntf = kODNULL;

    fSession = kODNULL;

    fTestDrawSU = kODNULL;

    fDisplayFrames = 0;
    fIsInitialized = kODFalse;
    fMenuBar = kODNULL;
    fPopup = kODNULL;
    memset(&fContentStruct, 0, sizeof(fContentStruct));
}

SimpleDTSPart::~SimpleDTSPart( )
{

    #define SEMANTIC_INTERFACES_NOT_DONE
    #ifndef SEMANTIC_INTERFACES_NOT_DONE
       if (fSemtIntf != kODNULL)
           delete fSemtIntf;
    #endif

    if (fDisplayFrames != kODNULL)
      delete fDisplayFrames;    // make sure it's empty first

    ODReleaseObject(fTestDrawSU);
}

void  SimpleDTSPart::FulfillPromise(  ODStorageUnitView* promiseSUView)
{
}

void  SimpleDTSPart::DropCompleted(  ODPart* destPart, ODDropResult dropResult)
{
}

MRESULT  SimpleDTSPart::DragEnter(  ODDragItemIterator* dragInfo, ODFacet* facet, ODPoint* where)
{

    return MRFROM2SHORT (DOR_NEVERDROP, DO_UNKNOWN);

}

MRESULT  SimpleDTSPart::DragWithin(  ODDragItemIterator* dragInfo, ODFacet* facet, ODPoint* where)
{
    return MRFROM2SHORT (DOR_NEVERDROP, DO_UNKNOWN);
}

void  SimpleDTSPart::DragLeave(  ODFacet* facet, ODPoint* where)
{
}

ODDropResult  SimpleDTSPart::Drop(  ODDragItemIterator* dropInfo, ODFacet* facet, ODPoint* where)
{
    return kODDropFail;


}

void  SimpleDTSPart::ContainingPartPropertiesUpdated(  ODFrame* frame, ODStorageUnit* propertyUnit)
{

}

ODStorageUnit*  SimpleDTSPart::AcquireContainingPartProperties(  ODFrame* frame)
{

    // this part has no properties to return
    return kODNULL;

}

ODBoolean  SimpleDTSPart::RevealFrame(  ODFrame* embeddedFrame, ODShape* revealShape)
{
    return kODFalse;
}

void  SimpleDTSPart::EmbeddedFrameSpec(  ODFrame* embeddedFrame, ODObjectSpec* spec)
{
}

ODEmbeddedFramesIterator*  SimpleDTSPart::CreateEmbeddedFramesIterator(  ODFrame* frame)
{
//  The following line has been commented out since we want this part
//  to return null.
//    THROW(kODErrCannotEmbed);
    return (ODEmbeddedFramesIterator *) kODNULL;
}

void  SimpleDTSPart::DisplayFrameAdded(  ODFrame* frame)
{
    fDisplayFrames->AddLast(frame);
    frame->Acquire();

   PartInfoRec* pInfo = (PartInfoRec*)frame->GetPartInfo();
   if (!pInfo)
   {
      pInfo = AllocFramePartInfo();
      if (frame->IsRoot())
        pInfo->fNeedsActivating = kODTrue;

      frame->SetPartInfo( (ODInfoType) pInfo);
   }
}

void  SimpleDTSPart::DisplayFrameConnected(  ODFrame* frame)
{
    fDisplayFrames->AddLast(frame);
    frame->Acquire();

   PartInfoRec* pInfo = (PartInfoRec*)frame->GetPartInfo();
   if (!pInfo)
   {
      pInfo = AllocFramePartInfo();
      if (frame->IsRoot())
         pInfo->fNeedsActivating = kODTrue;
      frame->SetPartInfo( (ODInfoType) pInfo);
   }
}

void  SimpleDTSPart::AttachSourceFrame(  ODFrame* frame, ODFrame* sourceFrame)
{
}

void  SimpleDTSPart::DisplayFrameRemoved(  ODFrame* frame)
{
    if (frame  != kODNULL)
    {
       if (fDisplayFrames->Contains(frame))
       {
          fSession->GetArbitrator()->RelinquishFocusSet( fFocusSet,frame );

          PartInfoRec* pInfo = (PartInfoRec*) frame ->GetPartInfo();
          frame ->SetPartInfo( (ODInfoType) kODNULL);
          delete pInfo;

          fDisplayFrames->Remove(frame);
          ODReleaseObject( frame);
       }
       else
          THROW(kODErrInvalidFrame);
    }
}

void  SimpleDTSPart::DisplayFrameClosed(  ODFrame* frame)
{
    if (frame  != kODNULL)
    {
       if (fDisplayFrames->Contains(frame))
       {
          fSession->GetArbitrator()->RelinquishFocusSet( fFocusSet,frame );

          PartInfoRec* pInfo = (PartInfoRec*) frame ->GetPartInfo();
          delete pInfo;

          fDisplayFrames->Remove(frame);
          ODReleaseObject( frame);
       }
       else
          THROW(kODErrInvalidFrame);
    }
}

void  SimpleDTSPart::FrameShapeChanged(  ODFrame* frame)
{
}

void  SimpleDTSPart::ViewTypeChanged(  ODFrame* frame)
{
}

void  SimpleDTSPart::PresentationChanged(  ODFrame* frame)
{
}

void  SimpleDTSPart::SequenceChanged(  ODFrame* frame)
{
}

void  SimpleDTSPart::WritePartInfo(  ODInfoType partInfo, ODStorageUnitView* storageUnitView)
{
}

ODInfoType  SimpleDTSPart::ReadPartInfo( ODFrame* frame, ODStorageUnitView* storageUnitView)
{
    return ((ODInfoType)kODNULL);
}

void  SimpleDTSPart::ClonePartInfo( ODDraftKey key, ODInfoType partInfo, ODStorageUnitView* storageUnitView, ODFrame* scopeFrame)
{
}

ODID  SimpleDTSPart::Open( ODFrame* frame)
{
    ODID windowID = 0;

    TempODWindow window = kODNULL;

    if (frame) // Doing a View As Window or Open Root
    {
        if (frame->IsRoot())  // Create Window For Root Frame
        {
                WindowProperties props;
                BeginGetWindowProperties(somGetGlobalEnvironment(),  frame, &props);

         ODULong flCreateFlags = props.createFlags ? props.createFlags :
                                                       ODPlatformWindowDefaultCreateOptions;

         HWND hwndFrame = fSession->CreatePlatformWindow( flCreateFlags);
         // position the window to shape it was closed in -? ben garrett
         // defect 117197 open from file in some position/properties as was saved
         WinSetWindowPos(hwndFrame, HWND_TOP, props.boundsRect.xLeft, props.boundsRect.yBottom, props.boundsRect.xRight, props.boundsRect.yTop,(SWP_SIZE | SWP_MOVE|props.swpFlags ));
         // defect 117197 end code added

                window =  fSession->GetWindowState()->RegisterWindowForFrame( hwndFrame, frame, props.isRootWindow,    // Keeps draft open
                                                                                                                 kODTrue,       // Is resizable
                                                                                                                 kODFalse,      // Is floating
                                                                                                                kODTrue,        // should save
                                                                                                                kODTrue,      // should dispose
                                                                                                                props.sourceFrame);
                EndGetWindowProperties(somGetGlobalEnvironment(),  &props); // Release source frame
                window->Open();
                window->Show();
        }
        else    // View In Window
      {
        window = fSession->GetWindowState()->AcquireWindow( windowID);
        if (window)
          window->Select();
        else
        {
          window = CreateWindow( frame);
          windowID = window->GetID();
          window->Open();
          window->Show();
          window->Select();
        }
      }
    }
    else
    {
      window = CreateWindow( frame);
      windowID = window->GetID();
      window->Open();
      window->Show();
      window->Select();
    }
    return windowID;
}

ODFrame*  SimpleDTSPart::RequestEmbeddedFrame(  ODFrame* containingFrame, ODFrame* baseFrame, ODShape* frameShape, ODPart* embedPart, ODTypeToken viewType, ODTypeToken presentation, ODBoolean isOverlaid)
{
    return baseFrame;
}

void  SimpleDTSPart::RemoveEmbeddedFrame(  ODFrame* embeddedFrame)
{
}

ODShape*  SimpleDTSPart::RequestFrameShape(  ODFrame* embeddedFrame, ODShape* frameShape)
{
    return frameShape;
}
void  SimpleDTSPart::UsedShapeChanged(  ODFrame* embeddedFrame)
{
}

ODShape*  SimpleDTSPart::AdjustBorderShape(  ODFacet* embeddedFacet, ODShape* shape)
{
    if ( shape == kODNULL )
      return kODNULL;
    shape->Acquire(); // [123773]
    return shape;
}

void  SimpleDTSPart::FacetAdded(  ODFacet* facet)
{
}

void  SimpleDTSPart::FacetRemoved(  ODFacet* facet)
{
}

void  SimpleDTSPart::CanvasChanged(  ODFacet* facet)
{
}

void  SimpleDTSPart::GeometryChanged(  ODFacet* facet, ODBoolean clipShapeChanged, ODBoolean externalTransformChanged)
{
}

void  SimpleDTSPart::Draw(  ODFacet* facet, ODShape* invalidShape)
{
    HPS hpsDraw;
    ODRect rect;
    TempODShape tempShape = facet->GetFrame()->AcquireFrameShape( kODNULL);
    tempShape->GetBoundingBox( &rect);
    RECTL frameRect;
    rect.AsRECTL(frameRect);

    CFocus f(somGetGlobalEnvironment(), facet, invalidShape, &hpsDraw);     // Set up drawing environment

    GpiSetColor(hpsDraw, fContentStruct.fColor);
    POINTL orig = {0, 0};
    GpiMove(hpsDraw, &orig);  // aml - [143687] background not printed on second page
    POINTL ptl = {frameRect.xRight, frameRect.yTop};
    GpiBox(hpsDraw, DRO_FILL, &ptl, 0, 0);

    GpiSetLineType(hpsDraw, LINETYPE_DASHDOUBLEDOT);
    GpiSetColor(hpsDraw, CLR_BLACK);

    // changed drawing of diagonal lines for Simple DTS Part

    for (int y = frameRect.yTop; y > 0; y -= YGRID) {
       ptl.y = y;
       ptl.x = 0;
       GpiMove(hpsDraw, &ptl);
       ptl.x = frameRect.xRight;
       ptl.y -= frameRect.xRight;
       GpiLine(hpsDraw, &ptl);
    }

    for (int x = XGRID; x < frameRect.xRight; x += XGRID) {
       ptl.x = x;
       ptl.y = frameRect.yTop;
       GpiMove(hpsDraw, &ptl);
       ptl.x += frameRect.yTop;
       ptl.y = 0;
       GpiLine(hpsDraw, &ptl);
    }

}

void  SimpleDTSPart::CanvasUpdated(  ODCanvas* canvas)
{
}

void  SimpleDTSPart::HighlightChanged(  ODFacet* facet)
{
    /*
     * cause ourselves to be redrawn.  FocusLib will take care of setting the
     * default mix mode so that we paint properly.
     */
    facet->Invalidate( kODNULL, kODNULL);
}


ODLinkSource*  SimpleDTSPart::CreateLink(  ODByteArray* data)
{
    return 0;

}

void  SimpleDTSPart::LinkUpdated(  ODLink* updatedLink, ODUpdateID id)
{
}

void  SimpleDTSPart::RevealLink(  ODLinkSource* linkSource)
{
}

void  SimpleDTSPart::BreakLink(  ODLink* link)
{
}

void  SimpleDTSPart::BreakLinkSource(  ODLinkSource* linkSource)
{
}

void  SimpleDTSPart::LinkBroken(  ODLink* link)
{
}

void  SimpleDTSPart::UpdateFromLinkSource(  ODLinkSource* linkSource)
{
}

void  SimpleDTSPart::ShowLink(  ODLink* link)
{
}

void  SimpleDTSPart::EmbeddedFrameUpdated(  ODFrame* frame, ODUpdateID change)
{
}

void  SimpleDTSPart::LinkStatusChanged(  ODFrame* frame)
{
}

ODBoolean  SimpleDTSPart::BeginRelinquishFocus(  ODTypeToken focus, ODFrame* ownerFrame, ODFrame* proposedFrame)
{

    return kODTrue;
}

void  SimpleDTSPart::CommitRelinquishFocus(  ODTypeToken focus, ODFrame* ownerFrame, ODFrame* proposedFrame)
{
    FocusLost( focus, ownerFrame);
}

void  SimpleDTSPart::AbortRelinquishFocus(  ODTypeToken focus, ODFrame* ownerFrame, ODFrame* proposedFrame)
{
}

void  SimpleDTSPart::FocusAcquired(  ODTypeToken focus, ODFrame* ownerFrame)
{
    if (focus == fSelectionFocus)
    {
      PartInfoRec* pInfo = (PartInfoRec*) ownerFrame->GetPartInfo();
      pInfo->fIsActive = kODTrue;
    } else if (focus == fMenuFocus) {
         fMenuBar->Display();
    }

}

void  SimpleDTSPart::FocusLost(  ODTypeToken focus, ODFrame* ownerFrame)
{
    if (focus == fSelectionFocus)
    {
      PartInfoRec* pInfo = (PartInfoRec*) ownerFrame->GetPartInfo();
      pInfo->fIsActive = kODFalse;
    }
}

void  SimpleDTSPart::CloneInto(  ODDraftKey key, ODStorageUnit* storageUnit, ODFrame* scopeFrame)
{
  ODStorageUnit*  su = GetStorageUnit();
  ODDraft*    draft = su->GetDraft();

  Externalize();

    ODID scopeFrameID = 0;
    if (scopeFrame != kODNULL)
      scopeFrameID = scopeFrame->GetStorageUnit()->GetID();
    su->CloneInto( key, storageUnit, scopeFrameID);

    if(!su->Exists( kODPropContents, kSimpleDTSPartKind, 0))
      su->AddProperty( kODPropContents)->AddValue( kSimpleDTSPartKind);
    StorageUnitSetValue(su, somGetGlobalEnvironment(), sizeof(simpleContent),  &fContentStruct);

}


void  SimpleDTSPart::ExternalizeKinds(  ODTypeList* kindset)
{
    Externalize();
}

void  SimpleDTSPart::Externalize( )
{

    ODStorageUnit* su = GetStorageUnit();

// add a value for color and set default color

     if(su->Exists( kODPropContents, kSimpleDTSPartKind, 0))
     {
         su->Focus( kODPropContents, kODPosUndefined, kSimpleDTSPartKind, 0, kODPosUndefined);
         su->Remove();
         su->AddValue( kSimpleDTSPartKind);
         StorageUnitSetValue(su, somGetGlobalEnvironment(), sizeof(simpleContent),  &fContentStruct);
     }
     else
     {
         su->AddProperty( kODPropContents)->AddValue( kSimpleDTSPartKind);
         StorageUnitSetValue(su, somGetGlobalEnvironment(), sizeof(simpleContent),  &fContentStruct);
     }

}

void  SimpleDTSPart::ChangeKind(  ODType kind)
{
    ODStorageUnit * su = GetStorageUnit();
    su->Focus(kODPropContents, kODPosUndefined, kODTypeAll, 0, kODPosUndefined);
    su->Remove();
    su->AddProperty(kODPropContents)->AddValue(kSimpleDTSPartKind);
    StorageUnitSetValue(su, somGetGlobalEnvironment(), sizeof(simpleContent),  &fContentStruct);
}

ODBoolean  SimpleDTSPart::HandleEvent(  ODEventData* event, ODFrame* frame, ODFacet* facet, ODEventInfo* eventInfo)
{
    ODBoolean handled = kODFalse;

    switch (event->msg)
    {
       case WM_BUTTON1DBLCLK:
       case WM_BUTTON2DBLCLK:
       case WM_BUTTON3DBLCLK:
          {
           Open( frame);
           handled = kODTrue;
          }
          break;

       case WM_BUTTON1CLICK:
          {
             ODPoint windowPt(ODIntToFixed(SHORT1FROMMP(event->mp1)),
                              ODIntToFixed(SHORT2FROMMP(event->mp1)));
             handled = HandleMouseDown(facet, &windowPt, event);

          }
          break;


       case WM_CONTEXTMENU       :
          {
           PartInfoRec* pInfo = (PartInfoRec*) frame->GetPartInfo();
           if (!(pInfo->fIsActive))
                 ActivateFrame( frame);
           fPopup->Display();
          handled = kODTrue;
          }
          break;
       case WM_CHAR:
          if (!(SHORT1FROMMP(event->mp1) & KC_KEYUP)) {
             handled = HandleKeyDown( frame, event);
          } /* endif */
          break;

       case WM_ACTIVATE:
          handled = kODTrue; // actually ignored by dispatcher
          if (SHORT1FROMMP(event->mp1) != 0)
             ActivatingWindow( frame);
          else
             DeActivatingWindow( frame);
          break;

       case WM_COMMAND:
          if (SHORT1FROMMP(event->mp2) & CMDSRC_MENU ||
              SHORT1FROMMP(event->mp2) & CMDSRC_ACCELERATOR)
          {
             handled = HandleMenuEvent( frame, event);
          }
          break;

       default:
          return kODFalse;
    }
    return handled;
}

ODBoolean  SimpleDTSPart::HandleEventInEmbedded(  ODEventData* event, ODFrame* frame, ODFacet* facet, ODFrame* embeddedFrame, ODFacet* embeddedFacet)
{
    return kODFalse;
}

void  SimpleDTSPart::MouseEnter(  ODFacet* facet, ODPoint* where)
{
                                      //   pointer type we prefer.
}

void  SimpleDTSPart::MouseWithin(  ODFacet* facet, ODPoint* where)
{
}

void  SimpleDTSPart::MouseLeave(  ODFacet* facet)
{
}

void  SimpleDTSPart::AdjustMenus(  ODFrame* frame)
{
    //enable the menu items that we support
    fMenuBar->EnableMenuItem(IDMS_VIEW,VIEW_SHOWAS,kODTrue);

    //PM will enable all submenus as well, so we disable the
    //views we don't support yet
    fMenuBar->EnableMenuItem(IDMS_VIEW,VIEW_SASMALLICON, kODFalse);
    fMenuBar->EnableMenuItem(IDMS_VIEW,VIEW_SALARGEICON, kODFalse);
    fMenuBar->EnableMenuItem(IDMS_VIEW,VIEW_SATHUMBNAIL, kODFalse);

}

void  SimpleDTSPart::UndoAction(  ODActionData* actionState)
{
    // not much to undo yet
}

void  SimpleDTSPart::RedoAction(  ODActionData* actionState)
{
    // not much to redo yet
}

void  SimpleDTSPart::DisposeActionState(  ODActionData* actionState, ODDoneState doneState)
{
    // not much to redo
}

void  SimpleDTSPart::WriteActionState(  ODActionData* actionState, ODStorageUnitView* storageUnitView)
{
}

ODActionData  SimpleDTSPart::ReadActionState(  ODStorageUnitView* storageUnitView)
{
    ODActionData data;
    data._maximum = 0;
    data._length = 0;
    data._buffer = kODNULL;
    return data;
}

void  SimpleDTSPart::InitPart(  ODStorageUnit* storageUnit, ODPart* partWrapper)
{
    if (fIsInitialized)
      return;

    fIsInitialized = kODTrue;
    fPartWrapper = partWrapper;

    ODPart::InitPart( storageUnit, partWrapper);


    fPartWrapper = partWrapper;

    CommonInitSimpleDTSPart();

    static int defcolor = 2;

    fContentStruct.fColor = (defcolor++) % 8;  // pick semi random color

    ODStorageUnit* su = GetStorageUnit();
    if(!su->Exists( kODPropContents, kSimpleDTSPartKind, 0))
    {
        su->AddProperty( kODPropContents)->AddValue( kSimpleDTSPartKind);
    }

   // The following code is a test for showing additional columns in the details
   // view. - UI Team. (125863)
   char *dummyStr = "Hello World";
   ODULong dummyNum = 98765;

    if(!su->Exists( kSimpleDTSPartAddProps, kODNULL, 0)) {
        su->AddProperty( kSimpleDTSPartAddProps);

        su->Focus( kSimpleDTSPartAddProps, kODPosUndefined, kODNULL, 0, kODPosUndefined);
        su->AddValue( kSimpleDTSPartAddProp1);
        StorageUnitSetValue(su, somGetGlobalEnvironment(), strlen(dummyStr) + 1,  dummyStr);

        su->Focus( kSimpleDTSPartAddProps, kODPosUndefined, kODNULL, 0, kODPosUndefined);
        su->AddValue( kSimpleDTSPartAddProp2);
        StorageUnitSetValue(su, somGetGlobalEnvironment(), sizeof(ODULong),  &dummyNum);

        time_t lt;
        time(&lt);
        su->Focus( kSimpleDTSPartAddProps, kODPosUndefined, kODNULL, 0, kODPosUndefined);
        su->AddValue( kSimpleDTSPartAddProp3);
        StorageUnitSetValue(su, somGetGlobalEnvironment(), sizeof(ODULong),  &lt);

    }

}

void  SimpleDTSPart::InitPartFromStorage(  ODStorageUnit* storageUnit, ODPart* partWrapper)
{

    if (fIsInitialized)
      return;

    fIsInitialized = kODTrue;
    fPartWrapper = partWrapper;

    ODPart::InitPartFromStorage( storageUnit, partWrapper);

    fPartWrapper = partWrapper;

    CommonInitSimpleDTSPart();

    static int defcolor = 2;

    ODStorageUnit* su = GetStorageUnit();

    // 125416
    if(!su->Exists( kODPropContents, kSimpleDTSPartKind, 0))
    {
        su->AddProperty( kODPropContents)->AddValue( kSimpleDTSPartKind);
    }
    // end 125416
    su->Focus( kODPropContents, kODPosUndefined, kSimpleDTSPartKind, 0, kODPosUndefined);
    StorageUnitGetValue(su, somGetGlobalEnvironment(), sizeof(simpleContent),& fContentStruct);

    // Clean up the storage unit
    su->Focus(kODPropContents, kODPosUndefined, kODTypeAll, 0, kODPosUndefined);
    su->Remove();
    su->AddProperty(kODPropContents)->AddValue(kSimpleDTSPartKind);

}

void  SimpleDTSPart::Release( )
{
    ODPart::Release();
    if (GetRefCount() == 0)
       GetStorageUnit()->GetDraft()->ReleasePart(this);
}

void  SimpleDTSPart::Activate(  ODFacet* facet)
{
    if (!facet->GetWindow()->IsActive())
       facet->GetWindow()->Select();
    else {
       PartInfoRec* pInfo = (PartInfoRec*) facet->GetFrame()->GetPartInfo();
       if (!pInfo->fIsActive) {
          ActivateFrame( facet->GetFrame());
       } /* endif */
    } /* endif */
}

#ifdef __IBMC___
  #pragma linkage (SOMInitModule, system)
#endif

SOMEXTERN void SOMLINK SOMInitModule (long majorVersion, long minorVersion, string className)
{
   SimpleDTSPartNewClass ( SimpleDTSPart_MajorVersion, SimpleDTSPart_MinorVersion);
}


ODBoolean  SimpleDTSPart::HasExtension(  ODType extensionName)
{
    return (ODPart::HasExtension( extensionName));
}

ODExtension*  SimpleDTSPart::AcquireExtension(  ODType extensionName)
{
    return (ODPart::AcquireExtension( extensionName));
}

void  SimpleDTSPart::ReleaseExtension(  ODExtension* extension)
{
    ODPart::ReleaseExtension( extension);
}


ISOString  M_SimpleDTSPart::clsGetODPartHandlerName( )
{
    string handlerName = kPartHandlerName;
    return (ISOString) handlerName;
}


string  M_SimpleDTSPart::clsGetODPartHandlerDisplayName( )
{
    string displayName =  "Simple DTS Part";
    return displayName;

}

_IDL_SEQUENCE_PartKindInfo  M_SimpleDTSPart::clsGetODPartKinds( )
{
    _IDL_SEQUENCE_PartKindInfo SimpleDTSPartInfo;
    // Create structure PartKindInfo  and allocate memory for variable
    PartKindInfo * info = (PartKindInfo *)SOMMalloc(sizeof(PartKindInfo));
    info->partKindName = (ISOString) SOMMalloc(strlen(kSimpleDTSPartKind) + 1);
    info->partKindDisplayName = (string)SOMMalloc(strlen(kSimpleDTSPartKindDisplayName)+1);
    info->filenameFilters =  (string)SOMMalloc(strlen("")+1);
    info->filenameTypes =  (string)SOMMalloc(strlen("")+1);
    info->categories =  (string)SOMMalloc(strlen(kSimpleDTSPartCategory) + 1);
    info->categoryDisplayName =  (string)SOMMalloc(strlen("Sample") + 1);
    info->objectID =  (string)SOMMalloc(strlen("") + 1);
    // Copy the information into the structure
    strcpy(info->partKindName , kSimpleDTSPartKind);
    strcpy(info->partKindDisplayName, kSimpleDTSPartKindDisplayName);
    strcpy(info->filenameFilters, "");
    strcpy(info->filenameTypes, "");
    strcpy(info->categories, kSimpleDTSPartCategory);
    strcpy(info->categoryDisplayName, "Sample");
    strcpy(info->objectID, "");


    SimpleDTSPartInfo._maximum = 1;
    SimpleDTSPartInfo._length = 1;
    SimpleDTSPartInfo._buffer = info;

    return SimpleDTSPartInfo;



}

string  M_SimpleDTSPart::clsGetOLE2ClassId( )
{
    string classID = "";
    return classID;
}

string  M_SimpleDTSPart::clsGetWindowsIconFileName( )
{
    string fileName = "";
    return fileName;
}

